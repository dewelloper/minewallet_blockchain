'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Exchange = require('bitcoin-exchange-client');
var Profile = require('./profile');
var Trade = require('./trade');
var PaymentMedium = require('./payment-medium');
var Quote = require('./quote');
var API = require('./api');

var assert = require('assert');

var Unocoin = function (_Exchange$Exchange) {
  _inherits(Unocoin, _Exchange$Exchange);

  function Unocoin(obj, delegate) {
    _classCallCheck(this, Unocoin);

    var api = new API('https://app-api.unocoin.com/');

    var _this = _possibleConstructorReturn(this, (Unocoin.__proto__ || Object.getPrototypeOf(Unocoin)).call(this, obj, delegate, api, Trade, Quote, PaymentMedium));

    assert(delegate.getToken, 'delegate.getToken() required');

    _this._user = obj.user;
    _this._auto_login = obj.auto_login;
    _this._offlineToken = obj.offline_token;

    _this._api._offlineToken = _this._offlineToken;

    _this._profile = null;

    _this._buyCurrencies = ['INR'];
    _this._sellCurrencies = ['INR'];
    return _this;
  }

  _createClass(Unocoin, [{
    key: 'toJSON',
    value: function toJSON() {
      var unocoin = {
        user: this._user,
        offline_token: this._offlineToken,
        auto_login: this._auto_login,
        trades: this._TradeClass.filteredTrades(this._trades)
      };

      return unocoin;
    }

    // Email must be set and verified

  }, {
    key: 'signup',
    value: function signup() {
      var self = this;
      var runChecks = function runChecks() {
        assert(self.delegate, 'ExchangeDelegate required');
        assert(self.delegate.email(), 'email required');
        assert(self.delegate.isEmailVerified(), 'email must be verified');
      };

      var doSignup = function doSignup(emailToken) {
        assert(emailToken, 'email token missing');
        return this._api.POST('api/blockchain-v1/authentication/register', {
          email_id: self.delegate.email()
        }, {
          Authorization: 'Bearer ' + emailToken
        });
      };

      var process = function process(res) {
        switch (res.status_code) {
          case 200:
            return res.access_token;
          case 724:
            return Promise.reject({ error: 'user is already registered', message: res.message });
          default:
            return Promise.reject({ error: res.status_code, message: res.message });
        }
      };

      var saveMetadata = function saveMetadata(accessToken) {
        this._user = self.delegate.email();
        this._offlineToken = accessToken;
        this._api._offlineToken = this._offlineToken;
        return this._delegate.save.bind(this._delegate)().then(function () {
          return;
        });
      };

      var getToken = function getToken() {
        return this.delegate.getToken.bind(this.delegate)('unocoin', { walletAge: true });
      };

      return Promise.resolve().then(runChecks.bind(this)).then(getToken.bind(this)).then(doSignup.bind(this)).then(process.bind(this)).then(saveMetadata.bind(this));
    }
  }, {
    key: 'fetchProfile',
    value: function fetchProfile() {
      var _this2 = this;

      return Profile.fetch(this.api).then(function (profile) {
        _this2._profile = profile;
        return profile;
      });
    }
  }, {
    key: 'getBuyCurrencies',
    value: function getBuyCurrencies() {
      return Promise.resolve(this._buyCurrencies);
    }
  }, {
    key: 'getSellCurrencies',
    value: function getSellCurrencies() {
      return Promise.resolve(this._sellCurrencies);
    }
  }, {
    key: 'getTrades',
    value: function getTrades() {
      var _this3 = this;

      return this.getTicker().then(function () {
        return _get(Unocoin.prototype.__proto__ || Object.getPrototypeOf(Unocoin.prototype), 'getTrades', _this3).call(_this3, Quote);
      });
    }
  }, {
    key: 'getBuyQuote',
    value: function getBuyQuote(amount, baseCurrency, quoteCurrency) {
      var _this4 = this;

      return this.getTicker().then(function () {
        return _get(Unocoin.prototype.__proto__ || Object.getPrototypeOf(Unocoin.prototype), 'getBuyQuote', _this4).call(_this4, amount, baseCurrency, quoteCurrency);
      });
    }
  }, {
    key: 'getTicker',
    value: function getTicker() {
      var _this5 = this;

      var price = function price() {
        return _this5.delegate.ticker.buy;
      };

      var process = function process(res) {
        // Store ticker on delegate so other classes can access it
        _this5.delegate.ticker = {
          buy: {
            price: res.buy,
            fee: res.buy_btc_fee,
            tax: res.buy_btc_tax
          },
          updatedAt: new Date()
        };
      };

      if (this.delegate.ticker && new Date() - this.delegate.ticker.updatedAt < 60 * 1000) {
        return Promise.resolve().then(price);
      } else {
        return this._api.POST('api/blockchain-v1/general/rates').then(process).then(price);
      }
    }
  }, {
    key: 'profile',
    get: function get() {
      return this._profile;
    }
  }, {
    key: 'hasAccount',
    get: function get() {
      return Boolean(this._offlineToken);
    }
  }, {
    key: 'buyCurrencies',
    get: function get() {
      return this._buyCurrencies;
    }
  }, {
    key: 'sellCurrencies',
    get: function get() {
      return this._sellCurrencies;
    }
  }, {
    key: 'bank',
    get: function get() {
      return this._bank;
    }
  }], [{
    key: 'new',
    value: function _new(delegate) {
      assert(delegate, 'Unocoin.new requires delegate');
      var object = {
        auto_login: true
      };
      var unocoin = new Unocoin(object, delegate);
      return unocoin;
    }
  }]);

  return Unocoin;
}(Exchange.Exchange);

module.exports = Unocoin;