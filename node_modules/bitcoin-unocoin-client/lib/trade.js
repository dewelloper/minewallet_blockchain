'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var assert = require('assert');

var Exchange = require('bitcoin-exchange-client');
var Helpers = Exchange.Helpers;

var BankAccount = require('./bank-account');

var Trade = function (_Exchange$Trade) {
  _inherits(Trade, _Exchange$Trade);

  function Trade(obj, api, delegate) {
    _classCallCheck(this, Trade);

    var _this = _possibleConstructorReturn(this, (Trade.__proto__ || Object.getPrototypeOf(Trade)).call(this, obj, api, delegate));

    assert(obj || obj === null, 'JSON or null missing');

    _this._inCurrency = 'INR';
    _this._outCurrency = 'BTC';

    _this._medium = 'bank';

    _this._createdAt = null;

    if (obj) {
      _this._id = obj.id;
      _this._state = obj.state;
      _this._txHash = obj.tx_hash;

      _this._delegate.deserializeExtraFields(obj, _this);
      _this._confirmed = obj.confirmed;

      _this._is_buy = obj.is_buy;
    } else {
      _this._is_buy = _this._inCurrency === 'INR';
    }

    if (_this._is_buy && Helpers.isPositiveInteger(_this._account_index) && Helpers.isPositiveInteger(_this._receive_index)) {
      _this._receiveAddress = _this._delegate.getReceiveAddress(_this);
    }
    return _this;
  }

  _createClass(Trade, [{
    key: 'setFromAPI',
    value: function setFromAPI(obj) {
      _get(Trade.prototype.__proto__ || Object.getPrototypeOf(Trade.prototype), 'setFromAPI', this).call(this);

      /* istanbul ignore if */
      if (this.debug) {
        console.info('Trade ' + this.id + ' from Unocoin API');
      }

      this._txHash = obj.transaction_hash;
      this._id = this._id || Trade.idFromAPI(obj);

      switch (obj.status) {
        /* Unocoin API only uses 'Pending' and 'Complete'. For consistentcy we
           map these to their equivalent Coinify states. Additional fields are
           used to determine this.
            Currently the API does not support:
           * 'reviewing': we can't tell when Unocoin has received the funds
           * 'cancelled': users can't cancel a trade
           * 'rejected': not possible afaik
           * 'expired': not possible afaik
        */
        case 'Pending':
          if (obj.reference_number) {
            this._state = 'awaiting_transfer_in';
          } else {
            this._state = 'awaiting_reference_number';
          }
          break;
        case 'Approved':
          this._state = 'processing';
          break;
        case 'Completed':
          this._state = 'completed';
          break;
        case 'Cancelled':
          this._state = 'cancelled';
          break;
        default:
          this._state = 'awaiting_reference_number';
      }

      if (obj.unix_time) {
        // API returns unix timestamp when creating a trade
        this._createdAt = new Date(obj.unix_time * 1000);
      } else if (obj.requested_time) {
        // API returns date-time string when listing trades
        this._createdAt = new Date(obj.requested_time);
      } else {
        console.warn('Unexpected missing field: requested_time / unixtime');
        this._createdAt = null;
      }

      this._inAmount = obj.inr;
      this._sendAmount = this._inAmount;

      this._outAmount = null;
      this._receiveAmount = null;

      if (obj.btc && obj.btc !== '' && obj.btc !== '0') {
        if (this.state !== 'completed') {
          this._receiveAmount = parseFloat(obj.btc);
        } else {
          this._outAmount = parseFloat(obj.btc);
          this._receiveAmount = this._outAmount;
        }
      } else if (this._delegate.ticker) {
        this._receiveAmount = parseFloat((this._inAmount / this._delegate.ticker.buy.price).toFixed(8));
      }
    }
  }, {
    key: 'refresh',


    // Fetches all, but only updates the current trade
    value: function refresh() {
      var self = this;

      var process = function process(res) {
        var transaction = res.find(function (tx) {
          return Trade.idFromAPI(tx) === self.id;
        });
        if (!transaction) {
          console.error('Unuable to find matching transaction in result');
          return Promise.reject('TX_NOT_FOUND');
        }
        self.setFromAPI(transaction);
      };

      return Trade.fetchAll(this._api).then(process).then(this._delegate.save.bind(this._delegate)).then(function () {
        return self;
      });
    }
  }, {
    key: 'addReferenceNumber',
    value: function addReferenceNumber(ref) {
      var _this2 = this;

      var processResult = function processResult(res) {
        if (res.status_code === 200) {
          _this2._state = 'awaiting_transfer_in';
          return Promise.resolve();
        } else {
          console.error('Failed to set reference number', res.status_code, res.message);
          return Promise.reject(res.message);
        }
      };
      return this._api.authPOST('api/blockchain-v1/wallet/add_reference', {
        inr_transaction_id: this._id,
        ref_num: ref
      }).then(processResult).then(this._delegate.save.bind(this._delegate)).then(this.self.bind(this));
    }
  }, {
    key: 'getBankAccountDetails',
    value: function getBankAccountDetails() {
      var processResult = function processResult(res) {
        if (res.status_code === 200) {
          return new BankAccount(res);
        } else {
          console.error('Failed to get bank account details', res.status_code, res.message);
          return Promise.reject(res.message);
        }
      };

      return this._api.authPOST('/api/blockchain-v1/general/inrdepositbankaccount').then(processResult);
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      var serialized = {
        id: this._id,
        state: this._state,
        tx_hash: this._txHash,
        confirmed: this.confirmed,
        is_buy: this.isBuy
      };

      this._delegate.serializeExtraFields(serialized, this);

      return serialized;
    }
  }, {
    key: 'isBuy',
    get: function get() {
      return this._is_buy;
    }
  }], [{
    key: 'buy',
    value: function buy(quote, medium) {
      var request = function request(receiveAddress) {
        return quote.api.authPOST('api/blockchain-v1/trading/instant_buyingbtc', {
          destination: receiveAddress,
          amount: quote.baseCurrency === 'INR' ? -quote.baseAmount : quote.quoteAmount
        }).then(function (res) {
          if (res.status_code === 200) {
            return res;
          } else {
            return Promise.reject(res.message);
          }
        });
      };
      return _get(Trade.__proto__ || Object.getPrototypeOf(Trade), 'buy', this).call(this, quote, medium, request);
    }
  }, {
    key: 'fetchAll',
    value: function fetchAll(api) {
      return api.authGET('api/blockchain-v1/wallet/deposit_history').then(function (res) {
        switch (res.status_code) {
          case 200:
            return res.transactions;
          case 716:
            // Transaction not found (pending API fix)
            return [];
          default:
            return Promise.reject(res.message);
        }
      });
    }
  }, {
    key: 'idFromAPI',
    value: function idFromAPI(obj) {
      // order_id is an integer when creating a trade, but a string when listing
      return parseInt(obj.order_id);
    }
  }]);

  return Trade;
}(Exchange.Trade);

module.exports = Trade;